{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pointer = void 0;\n/**\r\nUnescape token part of a JSON Pointer string\r\n\r\n`token` should *not* contain any '/' characters.\r\n\r\n> Evaluation of each reference token begins by decoding any escaped\r\n> character sequence.  This is performed by first transforming any\r\n> occurrence of the sequence '~1' to '/', and then transforming any\r\n> occurrence of the sequence '~0' to '~'.  By performing the\r\n> substitutions in this order, an implementation avoids the error of\r\n> turning '~01' first into '~1' and then into '/', which would be\r\n> incorrect (the string '~01' correctly becomes '~1' after\r\n> transformation).\r\n\r\nHere's my take:\r\n\r\n~1 is unescaped with higher priority than ~0 because it is a lower-order escape character.\r\nI say \"lower order\" because '/' needs escaping due to the JSON Pointer serialization technique.\r\nWhereas, '~' is escaped because escaping '/' uses the '~' character.\r\n*/\nfunction unescape(token) {\n  return token.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n/** Escape token part of a JSON Pointer string\r\n\r\n> '~' needs to be encoded as '~0' and '/'\r\n> needs to be encoded as '~1' when these characters appear in a\r\n> reference token.\r\n\r\nThis is the exact inverse of `unescape()`, so the reverse replacements must take place in reverse order.\r\n*/\nfunction escape(token) {\n  return token.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n/**\r\nJSON Pointer representation\r\n*/\nvar Pointer = /** @class */function () {\n  function Pointer(tokens) {\n    if (tokens === void 0) {\n      tokens = [''];\n    }\n    this.tokens = tokens;\n  }\n  /**\r\n  `path` *must* be a properly escaped string.\r\n  */\n  Pointer.fromJSON = function (path) {\n    var tokens = path.split('/').map(unescape);\n    if (tokens[0] !== '') throw new Error(\"Invalid JSON Pointer: \" + path);\n    return new Pointer(tokens);\n  };\n  Pointer.prototype.toString = function () {\n    return this.tokens.map(escape).join('/');\n  };\n  /**\r\n  Returns an object with 'parent', 'key', and 'value' properties.\r\n  In the special case that this Pointer's path == \"\",\r\n  this object will be {parent: null, key: '', value: object}.\r\n  Otherwise, parent and key will have the property such that parent[key] == value.\r\n  */\n  Pointer.prototype.evaluate = function (object) {\n    var parent = null;\n    var key = '';\n    var value = object;\n    for (var i = 1, l = this.tokens.length; i < l; i++) {\n      parent = value;\n      key = this.tokens[i];\n      if (key == '__proto__' || key == 'constructor' || key == 'prototype') {\n        continue;\n      }\n      // not sure if this the best way to handle non-existant paths...\n      value = (parent || {})[key];\n    }\n    return {\n      parent: parent,\n      key: key,\n      value: value\n    };\n  };\n  Pointer.prototype.get = function (object) {\n    return this.evaluate(object).value;\n  };\n  Pointer.prototype.set = function (object, value) {\n    var cursor = object;\n    for (var i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {\n      // not sure if this the best way to handle non-existant paths...\n      cursor = (cursor || {})[token];\n    }\n    if (cursor) {\n      cursor[this.tokens[this.tokens.length - 1]] = value;\n    }\n  };\n  Pointer.prototype.push = function (token) {\n    // mutable\n    this.tokens.push(token);\n  };\n  /**\r\n  `token` should be a String. It'll be coerced to one anyway.\r\n      immutable (shallowly)\r\n  */\n  Pointer.prototype.add = function (token) {\n    var tokens = this.tokens.concat(String(token));\n    return new Pointer(tokens);\n  };\n  return Pointer;\n}();\nexports.Pointer = Pointer;","map":{"version":3,"names":["Object","defineProperty","exports","value","Pointer","unescape","token","replace","escape","tokens","fromJSON","path","split","map","Error","prototype","toString","join","evaluate","object","parent","key","i","l","length","get","set","cursor","push","add","concat","String"],"sources":["C:/Users/Justin Neigh/WebstormProjects/GUI-based-Web-Game-with-Cloud-Native-Infrastructure-Backend/upwardmobility/node_modules/rfc6902/pointer.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Pointer = void 0;\r\n/**\r\nUnescape token part of a JSON Pointer string\r\n\r\n`token` should *not* contain any '/' characters.\r\n\r\n> Evaluation of each reference token begins by decoding any escaped\r\n> character sequence.  This is performed by first transforming any\r\n> occurrence of the sequence '~1' to '/', and then transforming any\r\n> occurrence of the sequence '~0' to '~'.  By performing the\r\n> substitutions in this order, an implementation avoids the error of\r\n> turning '~01' first into '~1' and then into '/', which would be\r\n> incorrect (the string '~01' correctly becomes '~1' after\r\n> transformation).\r\n\r\nHere's my take:\r\n\r\n~1 is unescaped with higher priority than ~0 because it is a lower-order escape character.\r\nI say \"lower order\" because '/' needs escaping due to the JSON Pointer serialization technique.\r\nWhereas, '~' is escaped because escaping '/' uses the '~' character.\r\n*/\r\nfunction unescape(token) {\r\n    return token.replace(/~1/g, '/').replace(/~0/g, '~');\r\n}\r\n/** Escape token part of a JSON Pointer string\r\n\r\n> '~' needs to be encoded as '~0' and '/'\r\n> needs to be encoded as '~1' when these characters appear in a\r\n> reference token.\r\n\r\nThis is the exact inverse of `unescape()`, so the reverse replacements must take place in reverse order.\r\n*/\r\nfunction escape(token) {\r\n    return token.replace(/~/g, '~0').replace(/\\//g, '~1');\r\n}\r\n/**\r\nJSON Pointer representation\r\n*/\r\nvar Pointer = /** @class */ (function () {\r\n    function Pointer(tokens) {\r\n        if (tokens === void 0) { tokens = ['']; }\r\n        this.tokens = tokens;\r\n    }\r\n    /**\r\n    `path` *must* be a properly escaped string.\r\n    */\r\n    Pointer.fromJSON = function (path) {\r\n        var tokens = path.split('/').map(unescape);\r\n        if (tokens[0] !== '')\r\n            throw new Error(\"Invalid JSON Pointer: \" + path);\r\n        return new Pointer(tokens);\r\n    };\r\n    Pointer.prototype.toString = function () {\r\n        return this.tokens.map(escape).join('/');\r\n    };\r\n    /**\r\n    Returns an object with 'parent', 'key', and 'value' properties.\r\n    In the special case that this Pointer's path == \"\",\r\n    this object will be {parent: null, key: '', value: object}.\r\n    Otherwise, parent and key will have the property such that parent[key] == value.\r\n    */\r\n    Pointer.prototype.evaluate = function (object) {\r\n        var parent = null;\r\n        var key = '';\r\n        var value = object;\r\n        for (var i = 1, l = this.tokens.length; i < l; i++) {\r\n            parent = value;\r\n            key = this.tokens[i];\r\n            if (key == '__proto__' || key == 'constructor' || key == 'prototype') {\r\n                continue;\r\n            }\r\n            // not sure if this the best way to handle non-existant paths...\r\n            value = (parent || {})[key];\r\n        }\r\n        return { parent: parent, key: key, value: value };\r\n    };\r\n    Pointer.prototype.get = function (object) {\r\n        return this.evaluate(object).value;\r\n    };\r\n    Pointer.prototype.set = function (object, value) {\r\n        var cursor = object;\r\n        for (var i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {\r\n            // not sure if this the best way to handle non-existant paths...\r\n            cursor = (cursor || {})[token];\r\n        }\r\n        if (cursor) {\r\n            cursor[this.tokens[this.tokens.length - 1]] = value;\r\n        }\r\n    };\r\n    Pointer.prototype.push = function (token) {\r\n        // mutable\r\n        this.tokens.push(token);\r\n    };\r\n    /**\r\n    `token` should be a String. It'll be coerced to one anyway.\r\n  \r\n    immutable (shallowly)\r\n    */\r\n    Pointer.prototype.add = function (token) {\r\n        var tokens = this.tokens.concat(String(token));\r\n        return new Pointer(tokens);\r\n    };\r\n    return Pointer;\r\n}());\r\nexports.Pointer = Pointer;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}